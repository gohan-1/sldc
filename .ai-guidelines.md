## AI Engineering Guidelines for This Repository

These rules are **mandatory** for any AI-driven changes in this repository (including subprojects like `express-postgres`). When in doubt, **do less**, ask for clarification, or refuse.

---

## 1. Coding Standards & Architectural Patterns

- **General principles**
  - **Prefer clarity over cleverness**: simple, readable code first; avoid premature optimization.
  - **Single-responsibility**: each module, class, and function should have one clear responsibility.
  - **Layered architecture** (already used in `express-postgres`):
    - **Router**: URL paths, HTTP verbs, and middleware wiring.
    - **Controller**: HTTP-level concerns (parsing inputs, choosing status codes, response shaping).
    - **Service**: Business logic, orchestration, domain rules.
    - **Repository**: Data access only (SQL/ORM), no business logic.
    - **Model/DTO**: Domain objects and DTO mapping.
  - **No hidden coupling**: do not let services reach directly into HTTP (no `req`, `res` in services); avoid repositories reading env directly.

- **JavaScript/TypeScript style**
  - Use **ES modules** consistently (`import`/`export`) as already configured.
  - Prefer **`const`** and **`let`**; never use `var`.
  - Keep functions small; if it exceeds ~40–50 lines, strongly consider splitting.
  - Validate all **external inputs** (request body, params, query, headers) before use.
  - Handle **errors explicitly**: throw or return clear `Error` objects; don’t silently swallow exceptions.

- **Express patterns**
  - **Routers**
    - Keep routers thin: define paths, HTTP verbs, middleware, and map to controller methods.
    - Use **RESTful conventions**:
      - Use `POST` for operations that require a body (e.g., `/login`, `/register`).
      - Use `GET` only for safe, idempotent, read operations.
  - **Controllers**
    - Do not contain SQL; only call services/repositories.
    - Always wrap logic in `try/catch` and return consistent error shapes.
    - Do not access `process.env` from controllers; that belongs in config/service layers if needed.
  - **Services**
    - Contain business rules, transformations, and orchestration across repositories.
    - May use configuration from dedicated config modules, not inline environment lookups spread around.
  - **Repositories**
    - All direct DB calls must live in repositories.
    - Always parameterize SQL queries; **never** interpolate raw user input into query strings.
    - Map DB rows to domain models/DTOs in a consistent way.

- **Configuration & environment**
  - All environment-dependent values (secrets, DB connection details, hostnames) must be read through config modules (e.g. `src/config/...`) and **never** hardcoded in business logic.
  - Do not introduce new secrets in code; always assume they will be provided via env variables or secret management tooling.

---

## 2. Testing Expectations

- **General**
  - For any **non-trivial change** (new endpoint, service method, or repository function), **add or update automated tests** in the same change set.
  - Prefer **fast, deterministic tests**. Do not depend on external services or real third‑party APIs in unit tests.
  - If the repo has an existing test framework (e.g., Jest, Mocha, Vitest), **reuse it**; do not introduce a second framework without explicit human approval.

- **Unit tests**
  - Required for:
    - Service methods (business logic, token handling, password hashing/verification).
    - Repository query behavior where logic is non-trivial (condition branches, error cases).
    - Middleware (e.g., authentication, authorization, input validation).
  - Use **test doubles** (mocks/spies) for:
    - DB access when testing services.
    - External HTTP calls.

- **Integration tests**
  - Required for:
    - Public HTTP endpoints (routers/controllers) that handle authentication, sessions, or complex flows.
    - Critical DB interactions (schema changes, transactional logic).
  - Integration tests should:
    - Use a **test database** (or in-memory alternative) with clear setup/teardown.
    - Never touch production databases or secrets.

- **Coverage expectations**
  - **New code**:
    - Aim for **≥ 80% line coverage** on new services, controllers, and repositories.
    - All new error branches and edge cases must be exercised at least once.
  - **Existing code touched by AI**:
    - If you significantly refactor behavior, add tests to cover the new behavior before or with the refactor.
  - If achieving coverage is not feasible (e.g., legacy, untestable code), the AI must:
    - Document the gap briefly (file, functions affected, missing tests).
    - Avoid risky refactors until testing strategy is approved by a human.

---

## 3. Security Requirements

- **Authentication & authorization**
  - Always use **JWT** or equivalent tokens following existing patterns for the project.
  - Secrets (`ACCESS_SECRET_KEY`, `REFRESH_SECRET_KEY`, etc.) must never be logged or hardcoded.
  - When adding endpoints under a protected resource (e.g., `/api/accounts`), ensure `authenticateToken` (or equivalent) is consistently enforced.
  - Do not weaken authentication (e.g., making auth optional) without explicit human approval.

- **Password handling**
  - Passwords must **always** be hashed (e.g., using `bcrypt`) before storage.
  - Never log raw passwords or password hashes.
  - Never return password fields (even hashed) in API responses or DTOs.

- **Data validation & sanitization**
  - Validate all incoming data (body, params, query) for:
    - Type, required/optional fields, allowed values.
    - Length, format (e.g., emails, UUIDs), and ranges.
  - Reject malformed or unexpected input with clear 4xx status codes (e.g., `400 Bad Request`).
  - Do not trust client-provided IDs or user identifiers without verifying they belong to the authenticated user when applicable.

- **Database & injection safety**
  - All DB access must use parameterized queries; **never** concat user input into SQL strings.
  - Do not expose internal DB errors directly to clients; log them server-side and return generic messages.

- **OWASP-aligned practices**
  - **Do not** introduce:
    - Insecure deserialization,
    - Raw eval/Function calls,
    - Dynamic `require`/imports based on user input.
  - Be conservative about error messages; avoid revealing stack traces, SQL, or sensitive environment details in HTTP responses.
  - Assume all inputs could be hostile; validate and encode where appropriate.

---

## 4. When the AI Must Refuse or Warn

- **High-risk or destructive operations**
  - Refuse to:
    - Modify or delete environment files with secrets (e.g., `.env`, `.env.*`) unless explicitly instructed and clearly safe.
    - Add code that sends secrets or sensitive data to third-party services or remote endpoints.
  - Warn and seek human confirmation before:
    - Schema-altering DB migrations that may drop or destructively change tables/columns.
    - Large-scale refactors that touch many files or core layers (e.g., changing auth scheme).

- **Ambiguous requirements**
  - If user intent is unclear (e.g., “make this better” with no specifics), the AI must:
    - Ask targeted clarifying questions, or
    - Provide a small, clearly-scoped improvement and explain what was done.
  - Do not invent business rules (e.g., password policies, authorization rules) without:
    - Either finding them in existing code/docs, or
    - Getting explicit confirmation from the user.

- **Security & compliance concerns**
  - Refuse to implement:
    - Backdoors or hidden access mechanisms.
    - Logging or exfiltration of secrets, tokens, or personal data.
  - Warn if user instructions appear to:
    - Bypass authentication/authorization protections.
    - Store or transmit sensitive data in plain text.

- **Testing & reliability**
  - Refuse to merge or finalize substantial logic changes **without any tests** when a test framework is present and reasonably usable.
  - If the user explicitly forbids tests, warn them about the risk and keep the changes minimal and well-documented.

---

## 5. Change Management Expectations for AI

- **Before changing code**
  - Understand the existing flow: trace from router → controller → service → repository → DB.
  - Identify any security, performance, or data‑integrity implications.

- **While changing code**
  - Keep commits/patches logically small and focused.
  - Preserve public APIs wherever possible; if API changes are necessary, document them clearly.

- **After changing code**
  - Ensure tests compile and run (when available).
  - Run linting/formatting tools if configured in the project.
  - Summarize changes at a high‑level for the user (what changed, why, and any risks or follow‑ups).


